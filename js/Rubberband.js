// Generated by CoffeeScript 1.12.4
var AnimatedValue, Easing, Elasticity, Number, ParabolicAnimation, Progress, TimingAnimation, Type, assertType, emptyFunction, isDev, type;

AnimatedValue = require("Animated").AnimatedValue;

Number = require("Nan").Number;

ParabolicAnimation = require("ParabolicAnimation");

TimingAnimation = require("TimingAnimation");

emptyFunction = require("emptyFunction");

assertType = require("assertType");

Progress = require("progress");

Easing = require("easing");

isDev = require("isDev");

Type = require("Type");

Elasticity = require("./Elasticity");

type = Type("Rubberband");

type.defineArgs(function() {
  return {
    required: {
      maxValue: true,
      maxVelocity: true
    },
    types: {
      maxValue: Number,
      maxVelocity: Number,
      elasticity: Number,
      restVelocity: Number,
      getDuration: Function
    },
    defaults: {
      elasticity: 0.8,
      restVelocity: 0.01
    }
  };
});

type.defineFrozenValues(function(options) {
  return {
    maxValue: options.maxValue,
    maxVelocity: options.maxVelocity,
    elasticity: options.elasticity,
    restVelocity: options.restVelocity,
    _delta: AnimatedValue(0),
    _easing: options.easing,
    __getDuration: options.getDuration
  };
});

type.defineGetters({
  isRebounding: function() {
    return this._delta.isAnimating;
  }
});

type.definePrototype({
  delta: {
    get: function() {
      return this._delta.get();
    },
    set: function(newValue) {
      return this._delta.set(newValue);
    }
  }
});

type.defineHooks({
  __getDuration: function(velocity, delta) {
    var minDuration;
    if (velocity > 0) {
      minDuration = 100 + 200 * Math.min(1, delta / 200);
      return minDuration + 300 * Math.min(1, velocity / this.maxVelocity);
    }
    return 400 + 200 * Math.min(1, delta / 200);
  }
});

type.defineMethods({
  resist: function() {
    return Elasticity.apply(Math.abs(this.delta), this.maxValue, this.elasticity);
  },
  rebound: function(config) {
    if (this._anim) {
      return this._anim;
    }
    isDev && assertType(config.velocity, Number);
    if (this.restVelocity >= Math.abs(config.velocity)) {
      config.velocity = 0;
    }
    if (config.velocity <= 0) {
      return this._reboundIn(config);
    } else {
      return this._reboundOut(config);
    }
  },
  stopRebounding: function() {
    this._delta.stopAnimation();
  },
  _getDuration: function(velocity) {
    var duration;
    duration = this.__getDuration(velocity, this.delta);
    assertType(duration, Number);
    return duration;
  },
  _reboundIn: function(config) {
    config.type = TimingAnimation;
    config.easing = Easing.bezier(0, 0.3, 0.5, 1);
    config.toValue = 0;
    config.duration = this._getDuration(config.velocity, this._delta._value);
    return this._delta.animate(config);
  },
  _reboundOut: function(config) {
    config.type = ParabolicAnimation;
    config.easing = Easing.bezier(0.15, 0.3, 0.5, 1);
    config.toValue = 0;
    config.duration = this._getDuration(config.velocity, this._delta._value);
    return this._delta.animate(config);
  }
});

type.defineStatics({
  Elasticity: Elasticity
});

module.exports = type.build();
